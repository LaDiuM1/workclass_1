/*
 	JS/JAVA : 객체 지향 언어 [ OOP : Object Oriented Programming] 
 	
 		클래스 = 사전적인 정의
 		객체 = 실제 존재하는 것 / 클래스 토대로 메모리에 할당된 것
		
		세상 모든 형태들을 코드화 = 객체
		대량화/자동화 ===> 객체지향 프로그래밍 적합하다.
			=> 미리 설계(클래스)하고 컴퓨터 설계 주입해서 설계기반으로 형태(객체) 생성
		ex)
			현대 소나타
				소나타생성설계=클래스 생성
				A소나타=객체 , B소나타=객체
			붕어빵
				붕어빵틀=클래스
				붕어빵1=객체 , 붕어빵2=객체
			00아파트 30평 아파트
				아파트도면도 = 클래스
				우리집=객체 , 옆집 = 객체
			23년신형 LG냉장고
				냉장고설계도 = 클래스
				냉장고 = 객체
		
		1. 정의 : 세상 존재하는 모든 형태를 코드화
		2. 목적 : :
			1. 형태를 코드화 [ 자동화 , 대량화 ] : 컴퓨터는 피로도 없으니까(=전기)
			2. 객체 특징 = JAVA
				1. 모듈개발 ( 분업화 ) / 유지보수 / 설계관리 복잡도 높음
				2. 다형성 ( 다양한 형태 설정 )
				
			- 객체안에 다른 객체 저장이 가능하다 : (우리집 = 객체, 옆집 = 객체)
		
		JS 객체 = JSON
			1.JS 메모리
				1. 변수 = 데이터 
				2. 상수 = 데이터
				3. 배열 = [ 데이터1, 데이터2, 데이터]
					- 배열 단점 : 서로 다른 정보유형들을 하나의 배열에 관리가 어렵다
						ex) 유재석/강호동/신동엽 3명의 회원(정보:아이디, 비밀번호, 이름 주소 등) 등록
							배열 설정 방법1 : 정보유형 분류 (데이터 유형이 아이디인지 비밀번호인지 식별)
										아이디배열 = [ ]
										비밀번호배열 = [ ]
										이름배열 = [ ]
										주소배열 = [ ]
							
									방법2 : 인덱스 기준 분류
										회원배열 [ 'qwe' , 'qwe' , '유재석', '안산' , 'asd' , 'asd']
										
									방법3 : 객체유형
										let 회원1 = { 아이디 : 'qwe' , 비밀번호 : 'qwe' , 이름 : '유재석' , 주소 : '안산'}
										let 회원2 = { 아이디 : 'asd' , 비밀번호 : 'asd' , 이름 : '강호동' , 주소 : '성남'}
										let 회원3 = { 아이디 : 'zxc' , 비밀번호 : 'zxc' , 이름 : '신동엽' , 주소 : '수원'}
				
				4. 객체 = { } 
					-1. 사용목적 : 서로 다른 데이터유형(속성) 들을 한곳에 저장 / 묶음
					-2. 형태
						let 객체명 = { 속성명 : 데이터 , 속성명 : 데이터 , 속성명 : 데이터 }
					-3. 선언
						키워드 객체명 = {
										속성명 : 데이터,
										속성명 : 변수,
										속성명 : 상수,
										속성명 : 배열,
										속성명 : 함수
									}	// 마지막에는 쉼표(,) 생략
				5. 객체 호출
						1. 객체 전체 : 객체명
						2. 객체내 특정 속성 호출 : 
							('.' 은 접근연산자 [ 객체내 속성 접근(호출)해서 데이터 호출 ]
				
				6. 객체 속성 값 변경
						객체명.속성명 = 새로운값
						
				7. 객체내 속성 추가
						객체명.새로운속성명 = 데이터
				
				8. 객체내 속성 삭제
						delete 객체1.주소;
						
				9. 여러개 객체 -> 관리( 배열 / 리스트 이용 ) <------------> JSON 형태
					회원객체1 , 1번게시물객체 , 회원객체 , 2번게시물 객체
					let 회원객체배열 = [ 회원객체1, 회원객체2 ]
					let 게시판객체배열 = [ 객체1, 객체2 ]
			 
 */

 //1. 객체 선언
 let 객체1 = { 아이디 : 'qwe' , 비밀번호 : '123' , 이름 : '유재석' }
 	//vs
 let 배열1 = [ 'qwe' , '123', '유재석' ]
 
 //2. 객체 호출
 console.log(객체1) // 객체1의 모든 정보 호출
 console.log(객체1.아이디) // 객체1의 특정 속성 데이터 호출
 console.log(객체1.비밀번호) // 객체내 속성 알고 있으면 데이터 호출 가능하다.
 //속성명을 모르면 호출이 불가하다. 그래서 속성명을 문서화하는 작업을 따로 해야함.
 	// console.log : 내장객체	-> console객체에서 log()함수 호출
 	// document.querySelector : 내장객체	-> document객체에서 querySelector()함수 호출
	// vs
console.log ( 배열1[0] ) // 배열로 호출하면 한 두개는 호출이 편하나 데이터가 많이지면 불리함.
// 3. 객체의 속성내 데이터 변경
객체1.비밀번호 = '123456' // [변경] 객체내 비밀번호 속성을 호출해서 새로운 데이터 대입
 
//4. 객체의 속성 추가 
객체1.주소 = '안산'; // [추가] 객체내 주소 속성이 없으므로 호출이 아닌 추가돼서 대입
console.log(객체1.주소)


//5. 객체의 속성 삭제
delete 객체1.주소
console.log(객체1)

// 6. 여러개의 동일한 유형의 객체를 하나의 배열 저장
 let 객체2 = { 아이디 : 'asd' , 비밀번호 : '123' , 이름 : '강호동' }
 let 객체3 = { 아이디 : 'zxc' , 비밀번호 : '123' , 이름 : '신동엽' }
 
 let 회원객체배열 = [객체1, 객체2, 객체3] 
console.log(회원객체배열)

// !!!!!! : JSON(통신 언어 표준) ---------> 서로 ( 웹/앱 관련 )언어들 간의 데이터 구조 형태



 